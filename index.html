<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>US CONVO</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  background: linear-gradient(135deg, #9b7fb5 0%, #d4a5d4 50%, #c8b3e6 100%);
  color: white;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  min-height: 100vh;
  padding: 20px;
}

.hidden {
  display: none !important;
}

.container {
  max-width: 700px;
  margin: 0 auto;
}

.box {
  background: rgba(155, 127, 181, 0.85);
  backdrop-filter: blur(10px);
  padding: 30px;
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(139, 69, 139, 0.4);
  border: 2px solid rgba(218, 165, 218, 0.5);
}

h2 {
  text-align: center;
  color: white;
  margin-bottom: 25px;
  font-size: 28px;
  text-shadow: 0 2px 8px rgba(139, 69, 139, 0.6);
  font-weight: 600;
}

.label {
  color: white;
  font-size: 14px;
  margin-bottom: 8px;
  font-weight: 500;
}

input[type="text"],
input[type="file"] {
  width: 100%;
  padding: 14px;
  margin-bottom: 15px;
  border-radius: 10px;
  font-size: 16px;
  border: 2px solid #daa5da;
  background: rgba(212, 165, 212, 0.3);
  color: white;
  transition: all 0.3s ease;
}

input[type="text"]::placeholder {
  color: rgba(255, 255, 255, 0.6);
}

input[type="text"]:focus {
  outline: none;
  border-color: white;
  background: rgba(212, 165, 212, 0.4);
  box-shadow: 0 0 15px rgba(218, 165, 218, 0.5);
}

button {
  width: 100%;
  padding: 14px;
  border-radius: 10px;
  font-size: 16px;
  border: none;
  background: linear-gradient(135deg, #ab7bab 0%, #8b458b 100%);
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  margin-bottom: 10px;
  box-shadow: 0 4px 12px rgba(139, 69, 139, 0.3);
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(139, 69, 139, 0.5);
  background: linear-gradient(135deg, #b98bb9 0%, #9b5a9b 100%);
}

button:active {
  transform: translateY(0);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.link-box {
  background: rgba(200, 179, 230, 0.3);
  padding: 15px;
  border-radius: 10px;
  border: 2px dashed rgba(218, 165, 218, 0.8);
  margin-bottom: 20px;
}

.link-box b {
  color: white;
  display: block;
  margin-bottom: 10px;
  font-size: 14px;
}

#room-link {
  background: rgba(155, 127, 181, 0.5);
  padding: 10px;
  border-radius: 6px;
  word-break: break-all;
  font-family: monospace;
  font-size: 12px;
  color: white;
  margin-bottom: 10px;
}

#timer {
  color: white;
  font-weight: bold;
  text-align: center;
  padding: 8px;
  font-size: 14px;
}

#status {
  text-align: center;
  padding: 10px;
  border-radius: 8px;
  margin-bottom: 15px;
  font-weight: 500;
  font-size: 14px;
}

#status.connecting {
  background: rgba(212, 165, 212, 0.3);
  color: white;
}

#status.connected {
  background: rgba(171, 123, 171, 0.4);
  color: white;
}

#status.error {
  background: rgba(139, 69, 139, 0.4);
  color: white;
}

#messages {
  height: 400px;
  overflow-y: auto;
  border: 2px solid rgba(218, 165, 218, 0.6);
  padding: 15px;
  background: rgba(155, 127, 181, 0.3);
  margin-bottom: 15px;
  border-radius: 10px;
  scroll-behavior: smooth;
}

#messages::-webkit-scrollbar {
  width: 8px;
}

#messages::-webkit-scrollbar-track {
  background: rgba(155, 127, 181, 0.2);
  border-radius: 10px;
}

#messages::-webkit-scrollbar-thumb {
  background: rgba(139, 69, 139, 0.6);
  border-radius: 10px;
}

#messages::-webkit-scrollbar-thumb:hover {
  background: rgba(139, 69, 139, 0.8);
}

.message {
  padding: 12px 15px;
  margin: 10px 0;
  border-radius: 12px;
  max-width: 75%;
  word-wrap: break-word;
  animation: slideIn 0.3s ease;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message.sent {
  background: linear-gradient(135deg, #c8b3e6 0%, #daa5da 100%);
  color: #4a2e5c;
  margin-left: auto;
  box-shadow: 0 2px 8px rgba(139, 69, 139, 0.2);
}

.message.received {
  background: linear-gradient(135deg, #ab7bab 0%, #9b7fb5 100%);
  color: white;
  box-shadow: 0 2px 8px rgba(139, 69, 139, 0.2);
}

.message .username {
  font-weight: bold;
  margin-bottom: 4px;
  font-size: 13px;
  opacity: 1;
}

.message.sent .username {
  color: #4a2e5c;
}

.message.received .username {
  color: white;
}

.message .text {
  font-size: 15px;
  line-height: 1.4;
}

.message img {
  max-width: 100%;
  height: auto;
  border-radius: 8px;
  margin-top: 8px;
  display: block;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.system-message {
  color: white;
  text-align: center;
  font-style: italic;
  padding: 8px;
  margin: 8px 0;
  font-size: 14px;
  opacity: 0.9;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.emoji-picker {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  margin-bottom: 15px;
  padding: 10px;
  background: rgba(200, 179, 230, 0.3);
  border-radius: 10px;
}

.emoji-picker span {
  font-size: 26px;
  cursor: pointer;
  transition: transform 0.2s ease;
  user-select: none;
}

.emoji-picker span:hover {
  transform: scale(1.3);
}

.emoji-picker span:active {
  transform: scale(1.1);
}

#file-input {
  display: none;
}

.file-button {
  background: linear-gradient(135deg, #9b7fb5 0%, #8b458b 100%);
  color: white;
}

.file-button:hover {
  background: linear-gradient(135deg, #ab8fc5 0%, #9b5a9b 100%);
}

.input-group {
  display: flex;
  gap: 10px;
  margin-bottom: 10px;
}

.input-group input {
  flex: 1;
  margin-bottom: 0;
}

.input-group button {
  width: auto;
  padding: 14px 25px;
  margin-bottom: 0;
}

.image-modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(75, 46, 92, 0.95);
  align-items: center;
  justify-content: center;
}

.image-modal.show {
  display: flex;
}

.image-modal img {
  max-width: 90%;
  max-height: 90%;
  object-fit: contain;
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
}

.image-modal .close {
  position: absolute;
  top: 20px;
  right: 35px;
  color: white;
  font-size: 40px;
  font-weight: bold;
  cursor: pointer;
  text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
  transition: transform 0.2s ease;
}

.image-modal .close:hover {
  transform: scale(1.2);
}

@media (max-width: 600px) {
  .box {
    padding: 20px;
  }
  
  .message {
    max-width: 85%;
  }
  
  h2 {
    font-size: 24px;
  }
}
</style>
</head>
<body>

<div class="container">
  <!-- Profile Setup Screen -->
  <div class="box" id="profile-screen">
    <h2>üíó US CONVO üíó</h2>
    <div class="label">Enter your name</div>
    <input id="username-input" type="text" placeholder="Your name" maxlength="20">
    <button onclick="initializeChat()">Create / Join Room</button>
  </div>

  <!-- Chat Screen -->
  <div class="box hidden" id="chat-screen">
    <h2>üí¨ Chat Room</h2>
    
    <!-- Room Link Section (only for host) -->
    <div class="link-box hidden" id="link-section">
      <b>üìã Share this room link (expires after 20 minutes)</b>
      <div id="room-link">Generating...</div>
      <div id="timer"></div>
      <button onclick="copyRoomLink()">Copy Link & Start Timer</button>
    </div>

    <!-- Connection Status -->
    <div id="status" class="connecting">Initializing...</div>

    <!-- Messages Container -->
    <div id="messages"></div>

    <!-- Emoji Picker -->
    <div class="emoji-picker">
      <span onclick="insertEmoji('üíó')">üíó</span>
      <span onclick="insertEmoji('üíñ')">üíñ</span>
      <span onclick="insertEmoji('üíï')">üíï</span>
      <span onclick="insertEmoji('üíì')">üíì</span>
      <span onclick="insertEmoji('üíû')">üíû</span>
      <span onclick="insertEmoji('üíò')">üíò</span>
      <span onclick="insertEmoji('ü©∑')">ü©∑</span>
      <span onclick="insertEmoji('üéÄ')">üéÄ</span>
      <span onclick="insertEmoji('üå∏')">üå∏</span>
      <span onclick="insertEmoji('‚ù§Ô∏è‚Äçüî•')">‚ù§Ô∏è‚Äçüî•</span>
    </div>

    <!-- Message Input -->
    <div class="input-group">
      <input id="message-input" type="text" placeholder="Type your message..." maxlength="500">
      <button onclick="sendMessage()">Send</button>
    </div>

    <!-- File Input -->
    <input type="file" id="file-input" accept="image/*">
    <button class="file-button" onclick="document.getElementById('file-input').click()">üì∑ Send Image</button>
  </div>
</div>

<!-- Image Modal -->
<div id="image-modal" class="image-modal" onclick="closeImageModal()">
  <span class="close">&times;</span>
  <img id="modal-image" src="" alt="Full size image">
</div>

<script>
// Global state
const state = {
  peer: null,
  connection: null,
  username: '',
  roomId: '',
  myPeerId: '',
  isHost: false,
  isConnected: false,
  linkExpired: false,
  timerInterval: null,
  reconnectAttempts: 0,
  maxReconnectAttempts: 3,
  peerReady: false
};

// Create send sound effect
const sendSound = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBDGD0fPTgjMGHm7A7+OZUQ0PVanm77BdGAg+ltryxmwnBjKB0PLSgDIFHmzA7+ObUQ4OV6zl776dUxILTqXh8bpsJAUuhND01oU0Bxtru+7mnlQODk+m4/C5Yh0FO5DX8sx6KwYohsvy1403CBlmu+3mnlQODU2k4fG6bCQGLoTR9NaEMwcZbbrv5J5UDg1NpOLwuWkcBTiP1/PNeCsGJ4TO8daCNggZZrvs5Z5UDg1MpOHxumwkBi6E0PTWhDMHGWy67+SeVA4NTKTi8LlpHAU4jtfzzXgrBieEzvLWgjYIGGa77eWeVBANTKPi8bpsIwYuhND01oQzBxlruu/knlQODUyk4vC5aRwGOI7X8814KwYnhM7y1oI2CBhmu+zlnlQQDUuj4vG6bCMGLoTQ9NaEMwcZa7rv5J5UDg1MpOLwuWkcBjiO1/PNeCsGJ4TO8taENggYZLrt5J9UEA1Lo+LxumwjBi6E0PTWhDMHGWu67+SeVA4NTKTi8LlpHAU4jtfzzXgrBieEzvLWgjYIGGS67eSfVBANS6Pi8bpsIwYuhND01YQzBxlruu/knlQODUyk4vC5aRwFOI7X8814KwYnhM7y1oI2CBhkuu3kn1QQDUuj4vG6bCMGLoTQ9NWEMwcZa7rv5J5UDg1MpOLwuGkcBTiO1/PNeCsGJ4PO8taCNggYZLrt5J9UEA1Lo+Lxumw');

// Generate unique IDs
function generateId(prefix = 'id') {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// Play send sound
function playSendSound() {
  try {
    sendSound.currentTime = 0;
    sendSound.play().catch(err => console.log('Sound play failed:', err));
  } catch (err) {
    console.log('Sound error:', err);
  }
}

// Initialize chat
function initializeChat() {
  const username = document.getElementById('username-input').value.trim();
  
  if (!username) {
    alert('Please enter your name');
    return;
  }
  
  if (username.length < 2) {
    alert('Name must be at least 2 characters');
    return;
  }
  
  state.username = username;
  
  // Switch to chat screen
  document.getElementById('profile-screen').classList.add('hidden');
  document.getElementById('chat-screen').classList.remove('hidden');
  
  // Check if joining existing room
  const urlParams = new URLSearchParams(window.location.search);
  const roomParam = urlParams.get('room');
  
  if (roomParam) {
    // Joining existing room
    joinRoom(roomParam);
  } else {
    // Creating new room
    createRoom();
  }
}

// Create new room (host)
function createRoom() {
  state.isHost = true;
  state.roomId = generateId('room');
  
  // Show link section
  document.getElementById('link-section').classList.remove('hidden');
  
  // Update URL
  const newUrl = `${window.location.origin}${window.location.pathname}?room=${state.roomId}`;
  window.history.replaceState({}, '', newUrl);
  
  // Display room link
  document.getElementById('room-link').textContent = newUrl;
  
  updateStatus('Creating room...', 'connecting');
  
  // Initialize peer
  state.peer = new Peer(state.roomId, {
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:global.stun.twilio.com:3478' }
      ]
    }
  });
  
  state.peer.on('open', (id) => {
    console.log('‚úÖ Peer opened with ID:', id);
    state.peerReady = true;
    updateStatus('Room created! Share the link üíó', 'connected');
    addSystemMessage('Room created! Waiting for your friend...');
  });
  
  state.peer.on('connection', (conn) => {
    console.log('üì• Incoming connection from:', conn.peer);
    
    // Check if link expired
    if (state.linkExpired) {
      conn.on('open', () => {
        conn.send({
          type: 'system',
          message: 'This room link has expired ‚ùå'
        });
        setTimeout(() => conn.close(), 100);
      });
      return;
    }
    
    // Check if already connected
    if (state.isConnected && state.connection) {
      conn.on('open', () => {
        conn.send({
          type: 'system',
          message: 'This room already has 2 people ‚ùå'
        });
        setTimeout(() => conn.close(), 100);
      });
      return;
    }
    
    // Accept connection
    handleConnection(conn);
  });
  
  state.peer.on('error', (err) => {
    console.error('‚ùå Peer error:', err);
    handlePeerError(err);
  });
  
  state.peer.on('disconnected', () => {
    console.log('‚ö†Ô∏è Peer disconnected from server');
    state.peerReady = false;
    if (state.reconnectAttempts < state.maxReconnectAttempts) {
      updateStatus('Reconnecting...', 'connecting');
      state.reconnectAttempts++;
      setTimeout(() => {
        if (state.peer && !state.peer.destroyed) {
          state.peer.reconnect();
        }
      }, 1000);
    } else {
      updateStatus('Disconnected from server', 'error');
    }
  });

  state.peer.on('close', () => {
    console.log('üîí Peer connection closed');
    state.peerReady = false;
  });
}

// Join existing room (guest)
function joinRoom(roomId) {
  state.isHost = false;
  state.roomId = roomId;
  state.myPeerId = generateId('guest');
  
  updateStatus('Connecting to room...', 'connecting');
  addSystemMessage('Connecting to room...');
  
  // Initialize peer
  state.peer = new Peer(state.myPeerId, {
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:global.stun.twilio.com:3478' }
      ]
    }
  });
  
  state.peer.on('open', (id) => {
    console.log('‚úÖ Peer opened with ID:', id);
    state.peerReady = true;
    addSystemMessage('Connecting to your friend...');
    
    // Connect to host
    setTimeout(() => {
      const conn = state.peer.connect(state.roomId, {
        reliable: true
      });
      
      if (!conn) {
        updateStatus('Failed to connect', 'error');
        addSystemMessage('Failed to create connection');
        return;
      }
      
      handleConnection(conn);
      
      // Set timeout for connection
      const connectionTimeout = setTimeout(() => {
        if (!state.isConnected) {
          updateStatus('Connection timeout', 'error');
          addSystemMessage('Could not connect to room. Link may be invalid.');
          if (conn) conn.close();
        }
      }, 15000);
      
      conn.on('open', () => {
        clearTimeout(connectionTimeout);
      });
      
    }, 1000);
  });
  
  state.peer.on('error', (err) => {
    console.error('‚ùå Peer error:', err);
    handlePeerError(err);
  });
  
  state.peer.on('disconnected', () => {
    console.log('‚ö†Ô∏è Peer disconnected from server');
    state.peerReady = false;
    if (state.reconnectAttempts < state.maxReconnectAttempts && !state.peer.destroyed) {
      updateStatus('Reconnecting...', 'connecting');
      state.reconnectAttempts++;
      setTimeout(() => {
        if (state.peer && !state.peer.destroyed) {
          state.peer.reconnect();
        }
      }, 1000);
    } else {
      updateStatus('Disconnected from server', 'error');
    }
  });

  state.peer.on('close', () => {
    console.log('üîí Peer connection closed');
    state.peerReady = false;
  });
}

// Handle peer connection
function handleConnection(conn) {
  console.log('üîó Setting up connection...');
  state.connection = conn;
  
  conn.on('open', () => {
    console.log('‚úÖ Connection established with:', conn.peer);
    state.isConnected = true;
    state.reconnectAttempts = 0;
    updateStatus('Connected! Start chatting üíó', 'connected');
    addSystemMessage('Connected! You can now chat üíó');
    
    // Send initial handshake
    try {
      conn.send({
        type: 'handshake',
        username: state.username,
        timestamp: Date.now()
      });
    } catch (err) {
      console.error('Failed to send handshake:', err);
    }
  });
  
  conn.on('data', (data) => {
    console.log('üì® Received data type:', data?.type);
    handleReceivedData(data);
  });
  
  conn.on('close', () => {
    console.log('üîå Connection closed');
    state.isConnected = false;
    updateStatus('Friend disconnected ‚ùå', 'error');
    addSystemMessage('Your friend disconnected ‚ùå');
    state.connection = null;
  });
  
  conn.on('error', (err) => {
    console.error('‚ùå Connection error:', err);
    if (state.isConnected) {
      addSystemMessage('Connection error occurred');
    }
  });
}

// Handle received data
function handleReceivedData(data) {
  if (!data || typeof data !== 'object') {
    console.warn('Invalid data received:', data);
    return;
  }
  
  try {
    switch (data.type) {
      case 'handshake':
        console.log('ü§ù Handshake received from:', data.username);
        break;
        
      case 'message':
        if (data.text) {
          displayMessage(data.username, data.text, false);
          playSendSound();
        }
        break;
        
      case 'image':
        if (data.imageData) {
          displayImage(data.username, data.imageData, false);
          playSendSound();
        }
        break;
        
      case 'system':
        if (data.message) {
          addSystemMessage(data.message);
        }
        break;
        
      default:
        console.warn('Unknown message type:', data.type);
    }
  } catch (err) {
    console.error('Error handling received data:', err);
  }
}

// Send message
function sendMessage() {
  if (!state.isConnected || !state.connection) {
    alert('Not connected! Wait for your friend to join.');
    return;
  }
  
  const input = document.getElementById('message-input');
  const text = input.value.trim();
  
  if (!text) return;
  
  try {
    // Send to peer
    state.connection.send({
      type: 'message',
      username: state.username,
      text: text,
      timestamp: Date.now()
    });
    
    // Display locally
    displayMessage(state.username, text, true);
    
    // Play send sound
    playSendSound();
    
    // Clear input
    input.value = '';
    input.focus();
  } catch (err) {
    console.error('Failed to send message:', err);
    addSystemMessage('Failed to send message');
  }
}

// Compress image before sending
function compressImage(file, maxSizeMB = 1) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = function(e) {
      const img = new Image();
      
      img.onload = function() {
        const canvas = document.createElement('canvas');
        let width = img.width;
        let height = img.height;
        
        // Calculate new dimensions (max 1200px on longest side)
        const maxDimension = 1200;
        if (width > height && width > maxDimension) {
          height = (height / width) * maxDimension;
          width = maxDimension;
        } else if (height > maxDimension) {
          width = (width / height) * maxDimension;
          height = maxDimension;
        }
        
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        // Try different quality levels to get under size limit
        let quality = 0.8;
        let compressedData = canvas.toDataURL('image/jpeg', quality);
        
        // Estimate size (base64 is ~33% larger than binary)
        let estimatedSizeMB = (compressedData.length * 0.75) / (1024 * 1024);
        
        while (estimatedSizeMB > maxSizeMB && quality > 0.1) {
          quality -= 0.1;
          compressedData = canvas.toDataURL('image/jpeg', quality);
          estimatedSizeMB = (compressedData.length * 0.75) / (1024 * 1024);
        }
        
        resolve(compressedData);
      };
      
      img.onerror = reject;
      img.src = e.target.result;
    };
    
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

// Display text message
function displayMessage(username, text, isSent) {
  const messagesDiv = document.getElementById('messages');
  
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
  
  const usernameDiv = document.createElement('div');
  usernameDiv.className = 'username';
  usernameDiv.textContent = username;
  
  const textDiv = document.createElement('div');
  textDiv.className = 'text';
  textDiv.textContent = text;
  
  messageDiv.appendChild(usernameDiv);
  messageDiv.appendChild(textDiv);
  messagesDiv.appendChild(messageDiv);
  
  // Scroll to bottom
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

// Display image message
function displayImage(username, imageData, isSent) {
  const messagesDiv = document.getElementById('messages');
  
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
  
  const usernameDiv = document.createElement('div');
  usernameDiv.className = 'username';
  usernameDiv.textContent = username;
  
  const img = document.createElement('img');
  img.src = imageData;
  img.alt = 'Shared image';
  img.onclick = function() {
    openImageModal(imageData);
  };
  
  messageDiv.appendChild(usernameDiv);
  messageDiv.appendChild(img);
  messagesDiv.appendChild(messageDiv);
  
  // Scroll to bottom
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

// Open image in modal
function openImageModal(imageSrc) {
  const modal = document.getElementById('image-modal');
  const modalImg = document.getElementById('modal-image');
  modal.classList.add('show');
  modalImg.src = imageSrc;
}

// Close image modal
function closeImageModal() {
  const modal = document.getElementById('image-modal');
  modal.classList.remove('show');
}

// Add system message
function addSystemMessage(text) {
  const messagesDiv = document.getElementById('messages');
  
  const messageDiv = document.createElement('div');
  messageDiv.className = 'system-message';
  messageDiv.textContent = `‚Ä¢ ${text}`;
  
  messagesDiv.appendChild(messageDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

// Update status
function updateStatus(text, type) {
  const statusDiv = document.getElementById('status');
  statusDiv.textContent = text;
  statusDiv.className = type;
}

// Handle peer errors
function handlePeerError(err) {
  console.error('Peer error type:', err.type);
  console.error('Full error:', err);
  
  switch (err.type) {
    case 'peer-unavailable':
      updateStatus('Room not found ‚ùå', 'error');
      addSystemMessage('Could not find room. The link may be invalid or expired.');
      break;
      
    case 'network':
      updateStatus('Network error ‚ùå', 'error');
      addSystemMessage('Network connection failed. Check your internet connection.');
      break;
      
    case 'server-error':
      updateStatus('Server error ‚ùå', 'error');
      addSystemMessage('PeerJS server error. Please try again in a moment.');
      break;
      
    case 'socket-error':
      updateStatus('Connection error ‚ùå', 'error');
      addSystemMessage('Socket error. Please refresh and try again.');
      break;
      
    case 'socket-closed':
      updateStatus('Connection closed ‚ùå', 'error');
      addSystemMessage('Connection was closed. Please refresh.');
      break;
      
    case 'unavailable-id':
      updateStatus('ID conflict ‚ùå', 'error');
      addSystemMessage('Room ID conflict. Please refresh and create a new room.');
      break;
      
    default:
      updateStatus('Connection error ‚ùå', 'error');
      addSystemMessage(`Error: ${err.type}. Please refresh the page.`);
  }
}

// Copy room link
function copyRoomLink() {
  const roomLink = document.getElementById('room-link').textContent;
  
  navigator.clipboard.writeText(roomLink).then(() => {
    addSystemMessage('Link copied! Share it with your friend üìã');
    
    // Start expiry timer if not already started
    if (!state.timerInterval) {
      startExpiryTimer();
    }
  }).catch((err) => {
    console.error('Copy failed:', err);
    alert('Failed to copy. Please copy the link manually.');
  });
}

// Start link expiry timer
function startExpiryTimer() {
  let timeLeft = 1200; // 20 minutes in seconds
  const timerDiv = document.getElementById('timer');
  
  function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }
  
  timerDiv.textContent = `Link expires in: ${formatTime(timeLeft)}`;
  
  state.timerInterval = setInterval(() => {
    timeLeft--;
    
    if (timeLeft <= 0) {
      clearInterval(state.timerInterval);
      state.linkExpired = true;
      timerDiv.textContent = '‚ö†Ô∏è Link expired';
      addSystemMessage('Room link expired. New users cannot join.');
    } else {
      timerDiv.textContent = `Link expires in: ${formatTime(timeLeft)}`;
    }
  }, 1000);
}

// Insert emoji
function insertEmoji(emoji) {
  const input = document.getElementById('message-input');
  input.value += emoji;
  input.focus();
}

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
  const messageInput = document.getElementById('message-input');
  const usernameInput = document.getElementById('username-input');
  const fileInput = document.getElementById('file-input');
  
  if (messageInput) {
    messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
  }
  
  if (usernameInput) {
    usernameInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        initializeChat();
      }
    });
    usernameInput.focus();
  }
  
  // Handle file selection with compression
  if (fileInput) {
    fileInput.addEventListener('change', async function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      if (!state.isConnected || !state.connection) {
        alert('Not connected! Wait for your friend to join.');
        e.target.value = '';
        return;
      }
      
      if (!file.type.startsWith('image/')) {
        alert('Please select an image file.');
        e.target.value = '';
        return;
      }
      
      // Show loading message
      addSystemMessage('Compressing and sending image...');
      
      try {
        // Compress image
        const compressedImage = await compressImage(file, 1);
        
        // Send to peer
        state.connection.send({
          type: 'image',
          username: state.username,
          imageData: compressedImage,
          timestamp: Date.now()
        });
        
        // Display locally
        displayImage(state.username, compressedImage, true);
        
        // Play send sound
        playSendSound();
        
        addSystemMessage('Image sent! üì∑');
      } catch (err) {
        console.error('Failed to send image:', err);
        addSystemMessage('Failed to send image');
      }
      
      // Clear input
      e.target.value = '';
    });
  }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (state.connection) {
    try {
      state.connection.close();
    } catch (err) {
      console.error('Error closing connection:', err);
    }
  }
  if (state.peer) {
    try {
      state.peer.destroy();
    } catch (err) {
      console.error('Error destroying peer:', err);
    }
  }
  if (state.timerInterval) {
    clearInterval(state.timerInterval);
  }
});

console.log('üöÄ US CONVO initialized');
</script>
</body>
</html>